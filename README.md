# Metabuild  
*Zero-to-hero, cross-platform build cocoon*  

> **Prerequisite:** a working installation of **Docker Instalation** (any recent 24-plus release on macOS, Windows, or modern Linux). That’s it.

***

## Repository layout

| Path | What lives here | Why it matters |
|------|-----------------|----------------|
| **`Dockerfile`** | Multi-stage Alpine image with every cross-compiler we care about | You never install toolchains locally. |
| **`metabuild`** & **`build.bat`** | One-shot launchers | Pull (or build) the image and drop you into `make`. |
| **`metabuild.mk`** | Matrix generator | Conjures targets like `clang-wasm`, `osx-arm64`, etc. |
| **`Makefile`** | Project rules | Builds **one binary per directory** in `src/`. |
| **`.dockerignore`** | Context diet plan | Keeps bulky things (.git, out/, IDE junk) out of image builds. |
| **`lib/`** | Git submodules | External code; pulled shallow for speed. |
| **`sys/`** | Header symlinks | Pretend-system roots for exotic targets. |
| **`inc/`** | Project headers | Stable API surface. |
| **`src/<app>/`** | Source trees | Each sub-dir becomes its own executable in `out/<target>/bin/`. |
| **`tpl/<template>/`** | Scaffolds | `make new basic mytool` clones a template straight into `src/`. |
| **`test/unit/`**<br>**`test/case/`**<br>**`test/load/`** | Three flavours of C tests | Run with pattern targets like `unit-test-parser`. |
| **`out/<target>/`** | Build artefacts | Autogenerated; ignored by Git. |
| **`doc/`** & **`web/`** | Writeups / static assets | Optional, kept outside the critical path. |

***

### How it works (hand-wavy edition)  
1. Launch script ensures the container exists.	
2. Inside the container, `metabuild.mk` figures out which compiler/arch pair you asked for.  
3. The top-level `Makefile` fans out over every `src/<app>/` folder and links an independent binary.  
4. Tests compile the same way, spitting coloured ✓/✗ lines.  

> We are working on a install system so you mostly can ignore this repo...
